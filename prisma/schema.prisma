generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

enum UserRole {
  DEVELOPER
  ADMIN
  CONSULTANT
  CANDIDATE
  CLIENT
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

model User {
  id                       String    @id @default(auto()) @map("_id") @db.ObjectId
  name                     String
  email                    String    @unique
  contactNumber            String
  password                 String
  role                     UserRole  @default(CANDIDATE)
  emailVerified            Boolean   @default(false)
  emailVerifiedDate        DateTime?
  verificationRequestCount Int       @default(0)
  verificationToken        String?
  passwordResetToken       String?
  hashedPassword           String

  // Relations to specialized profiles
  consultantProfile ConsultantProfile?
  clientProfile     ClientProfile?
  candidateProfile  CandidateProfile?

  // Relation fields for created and updated tags
  createdTags Tag[] @relation("TagCreatedBy")
  updatedTags Tag[] @relation("TagUpdatedBy")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ConsultantProfile {
  id                     String   @id @default(auto()) @map("_id") @db.ObjectId
  gender                 Gender
  emergencyContactNumber String
  permanentAddress       String
  currentAddress         String
  joiningDate            DateTime
  isActive               Boolean  @default(true)

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique @db.ObjectId

  jobsPosted         Job[] // Relation to jobs posted by the consultant
  assignedCandidates JobApplicant[] // Relation to candidates assigned by the consultant

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model CandidateProfile {
  id                     String   @id @default(auto()) @map("_id") @db.ObjectId
  gender                 Gender?
  emergencyContactNumber String?
  sector                 String?
  domain                 String?
  currentCtc             String?
  designation            String?
  currentCompany         String?
  currentJobLocation     String?
  totalWorkingExperience String?
  degree                 String?
  collegeName            String?
  graduationYear         String?
  previousCompanyName    String?
  resume                 String? // URL or file path to the resume
  candidateCode          String?
  skills                 String[]
  bulkUpload             Boolean? @default(false)

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique @db.ObjectId

  jobs JobApplicant[] // Array of jobs the candidate has applied for with status

  // New communication status fields
  mailSent         String?   @default("No") // To track if the email was sent
  mailSentDate     DateTime? // To store the date when the email was sent
  mailSubject      String? // To store the subject of the email sent
  mailTemplateName String? // To store the name of the email template used
  mailSender       String? // To store the name of the email Sender

  // Relation to the CandidateTag join model
  candidateTags CandidateTag[] // Many-to-many relation through the join model

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ClientProfile {
  id                     String   @id @default(auto()) @map("_id") @db.ObjectId
  emergencyContactNumber String
  gender                 Gender
  sector                 String
  domain                 String
  designation            String
  currentJobLocation     String
  functionalArea         String
  currentCtc             String
  dateOfJoining          DateTime
  clientCode             String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique @db.ObjectId

  company   Company? @relation(fields: [companyId], references: [id]) // Link to the Company model
  companyId String?  @db.ObjectId

  jobs Job[] // Relation to jobs associated with this client

  // New communication status fields for the client
  mailSent         Boolean   @default(false) // To track if the email was sent
  mailSentDate     DateTime? // To store the date when the email was sent
  mailSubject      String? // To store the subject of the email sent
  mailTemplateName String? // To store the name of the email template used

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Company {
  id                 String  @id @default(auto()) @map("_id") @db.ObjectId
  companyName        String  @unique // Unique name for the company
  companyDescription String? // Optional description about the company
  companyLogo        String? // Optional description about the company

  jobs    Job[] // Relation to jobs offered by the company
  clients ClientProfile[] // Relation to clients associated with this company

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Job {
  id                    String            @id @default(auto()) @map("_id") @db.ObjectId
  jobId                 String?
  jobTitle              String
  jobSector             String
  jobDomain             String
  jobDescription        String
  jobSalary             Float // Salary in LPA
  jobCode               String?
  skillsRequired        String[] // Array of skills
  jobLocation           String
  jobVacancies          Int
  jobVacanciesRemaining Int
  jobApplicants         JobApplicant[] // Array of job applicants
  postedBy              ConsultantProfile @relation(fields: [consultantId], references: [id], onDelete: Cascade)
  consultantId          String            @db.ObjectId

  jobCompany Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId  String  @db.ObjectId

  clientSpoc   ClientProfile? @relation(fields: [clientSpocId], references: [id], onDelete: Cascade)
  clientSpocId String?        @db.ObjectId // Field to link the Client Profile as SPOC for this job

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model JobApplicant {
  id                String            @id @default(auto()) @map("_id") @db.ObjectId
  candidateProfile  CandidateProfile  @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  candidateId       String            @db.ObjectId
  job               Job               @relation(fields: [jobId], references: [id], onDelete: Cascade)
  jobId             String            @db.ObjectId
  status            String // Status of the application (e.g., "Applied", "Interviewed", "Selected", etc.)
  // New field to track who assigned the candidate
  assignedById      String            @db.ObjectId
  assignedByName    String? // Optionally store the creator's ID
  consultantProfile ConsultantProfile @relation(fields: [assignedById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([candidateId, jobId]) // Ensure unique combination of candidate and tag
}

model EmailTemplate {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  name      String   @unique // Template name
  subject   String //Template Subject
  content   String // HTML content of the template
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Tag {
  id            String  @id @default(auto()) @map("_id") @db.ObjectId
  name          String // Name of the tag (e.g., "Urgent", "Experienced", etc.)
  description   String? // Optional description of the tag
  createdById   String? @db.ObjectId // Store the creator's user ID
  createdByName String? // Optionally store the creator's ID
  updatedById   String? @db.ObjectId // Store the updater's user ID
  updatedByName String? // Optionally store the creator's ID

  // Relations to User for creation and updates
  createdByUser User? @relation("TagCreatedBy", fields: [createdById], references: [id])
  updatedByUser User? @relation("TagUpdatedBy", fields: [updatedById], references: [id])

  // Relation to the CandidateTag join model
  candidateTags CandidateTag[] // Many-to-many relation through the join model

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Composite unique constraint to ensure each user can only create one tag with the same name
  @@unique([name, createdById]) // This ensures that a user can only create one tag with a specific name
}

model CandidateTag {
  id          String @id @default(auto()) @map("_id") @db.ObjectId
  candidateId String @db.ObjectId
  tagId       String @db.ObjectId

  // Set up the relations
  candidate CandidateProfile @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  tag       Tag              @relation(fields: [tagId], references: [id], onDelete: Cascade)

  assignedBy String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([candidateId, tagId]) // Ensure unique combination of candidate and tag
}
